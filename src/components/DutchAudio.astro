---
// This component auto-injects speaker buttons into:
// 1. Table cells with Dutch content (matching column headers)
// 2. Blockquote dialogues (lines starting with **Name:** ...)
// Also injects a collapsible Audio Player panel above the first audio table.
// Strips English translations before speaking.
---

<script>
  import { speakDutch, stopAll, whenVoicesReady, hasDutchVoice } from "../scripts/dutch-speech";
  import { buildAudioPanel, type SentenceGroup } from "../scripts/audio-panel";

  const AUDIO_HEADERS = new Set([
    // Vocabulary tables
    "dutch", "dutch word", "dutch expression", "dutch phrase",
    "example", "example sentence", "example sentences",
    "dialogue", "infinitive",
    // Diminutive / grammar tables
    "word", "diminutive", "singular", "plural", "original",
    "conjugation", "stem", "correct stem",
    "statement", "question", "inversion",
    // Verb conjugation person columns
    "ik", "jij", "hij/zij/het", "wij",
    // Additional grammar / verb columns
    "sentence", "base verb", "prefix",
    "normal", "inverted (question)",
    // Questions page
    "example question", "example answer", "tag",
    // Alphabet page
    "name", "spelling",
    // Verb present tense page
    "raw stem",
    // Word order page
    "position 1", "verb", "subject", "rest",
    // Pronunciation guide page
    "example words",
    // Phonetics guide page
    "proof (vowel follows)",
  ]);
  // Headers where a startsWith match is enough (e.g. "example (werken)", "antwoord a")
  const AUDIO_PREFIXES = ["example", "antwoord"];

  // Parse the SVG once into a reusable template
  const btnTemplate = document.createElement("template");
  btnTemplate.innerHTML = `<button type="button" class="dutch-audio-btn"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg></button>`;

  // Extract Dutch-only text from a cell, stripping English translations
  function getDutchText(cell: Element): string {
    const clone = cell.cloneNode(true) as Element;
    // Remove <em> elements (English translations in italics)
    clone.querySelectorAll("em").forEach(em => em.remove());
    let text = clone.textContent?.trim() ?? "";
    // Strip all parenthetical content containing letters (English translations)
    text = text.replace(/\s*\([^)]*[a-zA-Z][^)]*\)\s*/g, " ");
    // Strip IPA in square brackets [hɔnt] and slashes /maːn/
    text = text.replace(/\[[^\]]*\]/g, "");
    text = text.replace(/\/[^/]+\//g, "");
    // Strip arrow symbols (used in devoicing tables)
    text = text.replace(/→/g, "");
    // Strip remaining forward slashes between alternatives (hij/zij, zult / zal)
    // Note: IPA in /slashes/ is already removed above
    text = text.replace(/\s*\/\s*/g, " ");
    // Strip dashes used as separators (ha - uu - ie - es)
    text = text.replace(/\s*[–—]\s*/g, " ");
    text = text.replace(/\s+-\s+/g, " ");
    return text.replace(/\s+/g, " ").trim();
  }

  function createBtn(text: string): HTMLButtonElement {
    const btn = btnTemplate.content.firstElementChild!.cloneNode(true) as HTMLButtonElement;
    btn.ariaLabel = `Listen to "${text}" in Dutch`;
    btn.dataset.text = text;
    return btn;
  }

  // Event delegation: one listener on body handles all audio buttons
  document.addEventListener("click", (e: Event) => {
    const btn = (e.target as Element).closest?.(".dutch-audio-btn") as HTMLButtonElement | null;
    if (!btn) return;
    const text = btn.dataset.text;
    if (!text) return;
    speakDutch(text, btn);
  });

  // Find the nearest preceding heading for a given element
  function findHeading(el: Element): string {
    let prev = el.previousElementSibling;
    while (prev) {
      if (/^H[23]$/.test(prev.tagName)) {
        return prev.textContent?.trim() ?? "Untitled";
      }
      prev = prev.previousElementSibling;
    }
    return "Untitled";
  }

  const IPA_HEADERS = new Set(["ipa", "pronunciation"]);

  /* Move IPA from its own column to small text below the Dutch word,
     then hide the IPA column. Works with single and dual-IPA tables. */
  function relocateIPA() {
    for (const table of document.querySelectorAll("table")) {
      const headers = table.querySelectorAll("thead th");
      if (headers.length === 0) continue;

      // Find all IPA columns and their paired Dutch columns
      const ipaCols: { ipaIdx: number; dutchIdx: number }[] = [];
      headers.forEach((th, i) => {
        const text = th.textContent?.trim().toLowerCase() ?? "";
        if (!IPA_HEADERS.has(text)) return;
        // Pair with the nearest preceding Dutch/audio column
        let dutchIdx = -1;
        for (let j = i - 1; j >= 0; j--) {
          const hdr = headers[j].textContent?.trim().toLowerCase() ?? "";
          if (AUDIO_HEADERS.has(hdr) || AUDIO_PREFIXES.some(p => hdr.startsWith(p))) {
            // Make sure this Dutch column isn't already paired
            if (!ipaCols.some(c => c.dutchIdx === j)) { dutchIdx = j; break; }
          }
        }
        if (dutchIdx >= 0) ipaCols.push({ ipaIdx: i, dutchIdx });
      });
      if (ipaCols.length === 0) continue;

      // Move IPA text below Dutch text in each row
      const rows = table.querySelectorAll("tbody tr");
      for (const row of rows) {
        const cells = row.querySelectorAll("td");
        for (const { ipaIdx, dutchIdx } of ipaCols) {
          const ipaCell = cells[ipaIdx];
          const dutchCell = cells[dutchIdx];
          if (!ipaCell || !dutchCell) continue;
          const ipaText = ipaCell.textContent?.trim() ?? "";
          if (!ipaText) continue;
          const sub = document.createElement("span");
          sub.className = "dutch-ipa-sub";
          sub.textContent = ipaText;
          dutchCell.appendChild(sub);
          ipaCell.textContent = "";
          ipaCell.classList.add("ipa-col-hidden");
        }
      }

      // Hide IPA header cells
      for (const { ipaIdx } of ipaCols) {
        headers[ipaIdx].textContent = "";
        headers[ipaIdx].classList.add("ipa-col-hidden");
        // Also hide separator cells if they exist
        const sep = table.querySelector("thead tr:nth-child(2)");
        if (sep) {
          const sepCells = sep.querySelectorAll("th, td");
          if (sepCells[ipaIdx]) sepCells[ipaIdx].classList.add("ipa-col-hidden");
        }
      }
    }
  }

  function injectDutchAudio() {
    // First relocate IPA below Dutch words
    relocateIPA();

    const tables = document.querySelectorAll("table");
    const audioTables: HTMLTableElement[] = [];
    const groups: SentenceGroup[] = [];

    for (const table of tables) {
      const headers = table.querySelectorAll("thead th");
      const audioColIndices: number[] = [];
      headers.forEach((th, i) => {
        const text = th.textContent?.trim().toLowerCase() ?? "";
        if (AUDIO_HEADERS.has(text) || AUDIO_PREFIXES.some(p => text.startsWith(p))) {
          audioColIndices.push(i);
        }
      });
      if (audioColIndices.length === 0) continue;

      audioTables.push(table as HTMLTableElement);

      // Collect sentences for the audio panel
      const heading = findHeading(table);
      const sentences: { text: string; display: string }[] = [];

      const rows = table.querySelectorAll("tbody tr");
      for (const row of rows) {
        const cells = row.querySelectorAll("td");
        const rowTexts: string[] = [];
        const rowDisplays: string[] = [];
        const rowIpas: string[] = [];
        for (const colIdx of audioColIndices) {
          const cell = cells[colIdx];
          if (!cell || cell.querySelector(".dutch-audio-btn")) continue;
          const text = getDutchText(cell);
          if (!text) continue;
          cell.appendChild(createBtn(text));
          rowTexts.push(text);
          rowDisplays.push(text);
          // Extract IPA from relocated spans
          const ipaSpan = cell.querySelector('.dutch-ipa-sub');
          const ipa = ipaSpan?.textContent?.trim() ?? "";
          if (ipa) rowIpas.push(ipa);
        }
        if (rowTexts.length > 0) {
          sentences.push({
            text: rowTexts.join(". "),
            display: rowDisplays.join(" — "),
            ipa: rowIpas.length > 0 ? rowIpas.join(" — ") : undefined,
          });
        }
      }

      if (sentences.length > 0) {
        groups.push({ label: heading, sentences });
      }
    }

    // Handle blockquote dialogues
    const blockquotes = document.querySelectorAll("blockquote");
    for (const bq of blockquotes) {
      const paragraphs = bq.querySelectorAll("p");
      for (const p of paragraphs) {
        if (p.querySelector(".dutch-audio-btn")) continue;
        const strong = p.querySelector("strong");
        if (!strong) continue;
        const strongText = strong.textContent ?? "";
        if (!strongText.includes(":") && !p.textContent?.match(/^[^:]+:/)) continue;
        const clone = p.cloneNode(true) as HTMLParagraphElement;
        clone.querySelectorAll("strong").forEach(s => s.remove());
        clone.querySelectorAll("em").forEach(em => em.remove());
        let text = clone.textContent?.trim() ?? "";
        text = text.replace(/^[:\s]+/, "");
        text = text.replace(/\s*\([^)]*[a-zA-Z][^)]*\)\s*/g, " ");
        text = text.replace(/\/[^/]+\//g, "");
        text = text.replace(/\s+/g, " ").trim();
        if (!text || text.length < 2) continue;
        p.appendChild(createBtn(text));
      }
    }

    // Inject Audio Player panel before the first audio table
    if (audioTables.length > 0 && groups.length > 0) {
      const panel = buildAudioPanel(groups);
      audioTables[0].parentElement?.insertBefore(panel, audioTables[0]);

      // After voices are resolved, warn if no Dutch voice is available
      whenVoicesReady(() => {
        if (!hasDutchVoice()) {
          const summary = panel.querySelector(".audio-panel-summary");
          if (summary) {
            const note = document.createElement("span");
            note.className = "ap-no-dutch-voice";
            note.textContent = " (no Dutch voice — install a Dutch TTS voice for correct pronunciation)";
            note.style.cssText = "font-size: 0.8em; color: var(--sl-color-text-accent, #888); margin-left: 4px;";
            summary.appendChild(note);
          }
        }
      });
    }
  }

  // Defer injection to avoid blocking first paint
  function scheduleInjection() {
    if ("requestIdleCallback" in window) {
      requestIdleCallback(injectDutchAudio);
    } else {
      requestAnimationFrame(() => setTimeout(injectDutchAudio, 0));
    }
  }

  // Stop audio on page navigation
  document.addEventListener("astro:before-swap", () => {
    stopAll();
  });

  scheduleInjection();
  document.addEventListener("astro:after-swap", scheduleInjection);
</script>
